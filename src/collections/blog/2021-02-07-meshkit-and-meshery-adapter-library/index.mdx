---
title: "Meshkit and Meshery Adapter Library"
subtitle: "Common libraries for improved developer experience."
date: 2021-02-07 12:12.12 +0002
author: Michael Gfeller
thumbnail: ./meshery.png
category: Announcements
tags:
 - Community
 - Projects
 - News
published: true
redirect_from:
 - /blog/meshery/meshkit-and-meshery-adapter-library/
---

import { BlogWrapper } from "../Blog.style.js";
import meskitKubernetesExample from "./meshkit-kubernetes-example.png";
import adapterHandlerInterface from "./adapter-handler-interface.png";
import meshServiceServer from "./mesh-service-server.png"
import malOverview from "./meshery-adapter-library-overview.png"

<BlogWrapper>

The Meshery v0.5.0 release includes two new libraries: Meshkit and Meshery Adapter Library. 

These two libraries improve developer experience and development speed, allowing developers to focus on creating differentiating value, 
instead of having to implement much of the required and inevitable plumbing. 

### Meshkit provides functionality useful in all Meshery code.

Meshkit has been around for a while, it was formerly named `gokit`. In this release, meshkit has been enhanced and expanded 
substantially, and is used in a growing number of Meshery applications.

The meshkit library provides functionality useful in all Meshery code. It is intended to be one of the top level libraries in the Meshery ecosystem.
 
It is a toolkit for Layer5’s microservices, and it is intended to become Layer5’s middleware component for Layer5’s microservices, leveraging other libraries like `go-kit/kit`.

Its purpose is to also provide implementations for common cross-cutting concerns like error handling, logging, and tracing.
Common error handling and logging helps to implement efficient tooling for observability, monitoring and troubleshooting.
 
It provides some common data models for Meshery, notably for Service Mesh Interface conformance testing, and Kubernetes' kubeconfig.

Another central component in Meshkit is the `utils` package.

It provides a Kubernetes and a Helm client that implement functionality based on the Go libraries of these tools.
The API exposed by these libraries is quite low-level, and the higher-level functions of the utils package simplify usage of Kubernetes and Helm client significantly.

Another advantage is that it is not necessary to use the command line versions of these tools, providing a more tailored experience for developers, 
and better logging and error handling integration.

It is simple and straight forward to use, as the following code example illustrates.   

<img src={meshServiceServer} class="image-center" alt="meshkit kubernetes example" />


```go
package main

import (
	"os"

	mkitlogger "github.com/layer5io/meshkit/logger"
	mkitkube "github.com/layer5io/meshkit/utils/kubernetes"
	"k8s.io/client-go/kubernetes"
)

func main() {
	// nginx contains the deployment manifest for nginx.
	nginx := `apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # tells deployment to run 2 pods matching the template
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
`

	// Create an instance of the meshkit logger handler, providing standardized output format.
	log, err := mkitlogger.New("ExampleApp", mkitlogger.Options{Format: mkitlogger.JsonLogFormat, DebugLevel: false})
	if err != nil {
		os.Exit(1)
	}
	log.Info("Successfully instantiated meshkit logger")

	// Detect the kubeconfig on the local system.
	config, err := mkitkube.DetectKubeConfig()
	if err != nil {
		log.Error(err)
		os.Exit(1)
	}
	log.Info(config.Host)

	// Create Kubernetes client set for the detected kubeconfig. 'kubernetes' is from the Kubernetes Go client.
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		log.Error(err)
		os.Exit(1)
	}

	// Create an instance of the meshkit Kubernetes client ...
	client, err := mkitkube.New(clientset, *config)
	if err != nil {
		log.Error(err)
		os.Exit(1)
	}

	// ... and use it to deploy nginx to the cluster.
	err2 := client.ApplyManifest([]byte(nginx), mkitkube.ApplyOptions{
		Namespace: "default",
		Update:    true,
		Delete:    false,
	})

	if err2 != nil {
		log.Error(err2)
		os.Exit(1)
	}
}
```

### Meshery Adapters

> Meshery adapters manage the lifecycle of service meshes.

Meshery adapters are management plane components and manage the lifecycle of service meshes. 
This includes installation and deletion, configuration, and verification that an installation follows recommended practices. 
In addition, Meshery adapters can assess to what extent a service mesh complies to the Service Mesh Interface standard. 

Adapters include also sample applications that can be deployed for easy and quick exploration of service mesh capabilities.

All Meshery adapters are packaged as Docker images. They expose the following gRPC API:

<img src={meshServiceServer} class="image-center" alt="mesh service server grpc" />

In other words, a Meshery adapter is a gRPC server that exposes this interface. 

This is one of the extension points Meshery, making it easy to add support for new service meshes to Meshery.

> Meshery adapters abstract away the differences in how service meshes are installed and configured.

Meshery adapters abstract away the differences in how service meshes are installed and configured. 
For instance, some service meshes have their own installer, like `istioctl` for Istio, while others use Helm charts, like Consul. 

### Meshery Adapter Library 

As can be expected, adapters for the various meshes have a lot of code in common. 

Initially, this common code was copied from one adapter implementation to the next. 

The question arose whether common code should be factored out to one or several common libraries. 

After some discussion, the community decided to move some of the more general code to meshkit, and adapter specific code to a new library.

Thus, the Meshery Adapter Library was born.

It reduces the amount of boilerplate code in the adapters substantially, making adapter code easier to follow.
This is especially valuable in an open source community where typically many developers contribute, for varying amounts of time.
For the same reasons, it is important such libraries are easily understandable.  
 
Also, it means new adapters can be implemented quickly, as nly configuration and operations that differ between services meshes need to be implemented. 

> The Meshery Adapter Library provides a common and consistent set of functionality that Meshery adapters use for  
> managing the lifecycle of service meshes and their workloads.

The initial commit was submitted on October 6th 2020 based on a refactoring effort in the adapter for the Kuma service mesh. 
Within a few months, several adapters have been refactored or implemented from scratch based on this common library.

The main purpose of the Meshery Adapter Library is to
* provide a set of interfaces, some with default implementations, to be used and extended by adapters.
* implement cross-cutting concerns like logging, error handling, and tracing.
* provide a mini framework implementing the gRPC server that allows plugging in the mesh specific configuration and operations implemented in the adapters.

The figure below illustrates the usage of the library in an adapter, leveraging UML notation.

The library is represented by the top package, the adapter code by the bottom package. 

By struct embedding, the adapter extends the default implementation `Adapter` of the interface `Handler` from the library, for the adapter specific lifecycle management operations.

The `Handler` interface looks like this:

<img src={adapterHandlerInterface} class="image-center" alt="adapter handler interface" />

In the `main` package of the adapter, the default configuration provider `Viper` from the library is instantiated, and reads the adapter specific configuration. 
This includes a specification of all available operations.

The `Service` struct from the library implements both the adapter handler and the gRPC service interface, `MeshServiceServer`. 
The concrete adapter handler implementation (TODO: callout numbers) is used in the `Service` instance. The `Start` function from 
the library wraps the gRPC server, wiring up all necessary components, and starts the service. The developer does not need to touch 
any gRPC code.  

<img src={malOverview} class="image-center" alt="meshkit adapter library overview" />

### Conclusion

Extracting common code from adapters to the two new libraries has proven to be a worthwhile investment. 
It led to cleaner code as well as cleaner application architecture, and shortened implementation time for new adapters considerably.
The libraries are continuously improved and extended. 

\- Michael Gfeller

_**P.S.: If these topics excite you and you want to explore the beautiful realm of service meshes, come and say "Hi" on our [Slack Channel](http://slack.layer5.io) and one of us will reach out to you!**_

</BlogWrapper>
